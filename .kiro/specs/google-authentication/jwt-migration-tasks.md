# SESSION_ENCRYPTION_KEY削除とJWT完全移行タスク

## 概要

デスクトップアプリ側の`SESSION_ENCRYPTION_KEY`を削除し、すべての認証処理をAPIサーバー側のJWTに統一する。これにより、セキュリティを向上させ、認証処理を一元化する。

## 目標

1. デスクトップアプリ側から暗号化キーを削除
2. セッション管理をAPIサーバー側に完全委譲
3. JWT方式による統一的な認証フロー
4. リフレッシュトークンによる自動更新機能

## タスクリスト

### フェーズ1: APIサーバー側の実装

#### 1.1 JWT検証エンドポイントの追加
- [x] `GET /api/v1/auth/validate` エンドポイントを実装
  - リクエストヘッダーから`Authorization: Bearer <token>`を取得
  - JWTトークンを検証（署名、有効期限）
  - ユーザー情報を返却
  - エラーハンドリング（401 Unauthorized）

#### 1.2 リフレッシュトークンエンドポイントの追加
- [ ] `POST /api/v1/auth/refresh` エンドポイントを実装
  - リクエストボディから`refresh_token`を取得
  - リフレッシュトークンを検証
  - 新しいアクセストークンを発行
  - 新しいリフレッシュトークンを発行（オプション）

#### 1.3 認証コールバックレスポンスの拡張
- [ ] `POST /api/v1/auth/google/callback` のレスポンスを拡張
  - `refresh_token`を追加
  - `refresh_expires_in`を追加（30日）
  - レスポンス型を更新

#### 1.4 JWT設定の調整
- [ ] アクセストークンの有効期限: 1時間
- [ ] リフレッシュトークンの有効期限: 30日
- [ ] JWTペイロードに必要な情報を含める
  - `sub`: Google User ID
  - `email`: メールアドレス
  - `name`: 表示名
  - `picture`: プロフィール画像URL
  - `iat`: 発行日時
  - `exp`: 有効期限

#### 1.5 JWT検証ミドルウェアの実装
- [ ] 認証が必要なエンドポイントで使用するミドルウェア
- [ ] トークン検証ロジックの共通化
- [ ] エラーレスポンスの統一

### フェーズ2: デスクトップアプリ側の実装

#### 2.1 session.rsの削除
- [ ] `packages/desktop/src-tauri/src/features/auth/session.rs` を削除
- [ ] `SessionManager`構造体の削除
- [ ] 暗号化/復号化機能の削除
- [ ] データベースからのセッション管理機能の削除

#### 2.2 secure_storage.rsの簡素化
- [ ] JWTトークンのみを保存（暗号化不要）
- [ ] `save_access_token()` メソッドの追加
- [ ] `save_refresh_token()` メソッドの追加
- [ ] `get_access_token()` メソッドの追加
- [ ] `get_refresh_token()` メソッドの追加
- [ ] 暗号化関連のコードを削除

#### 2.3 service.rsの更新
- [ ] `validate_session()` メソッドをAPIサーバー経由に変更
  - `GET /api/v1/auth/validate` を呼び出し
  - JWTトークンをBearerトークンとして送信
  - ユーザー情報を取得
- [ ] `refresh_token()` メソッドの追加
  - `POST /api/v1/auth/refresh` を呼び出し
  - 新しいトークンを取得
  - セキュアストレージに保存
- [ ] `handle_loopback_callback()` の更新
  - リフレッシュトークンも保存

#### 2.4 commands.rsの更新
- [ ] `validate_session` コマンドの更新
  - APIサーバー経由の検証に変更
- [ ] `refresh_token` コマンドの追加
  - トークンリフレッシュ機能
- [ ] セッション関連のコマンドを簡素化

#### 2.5 environment.rsの更新
- [ ] `SESSION_ENCRYPTION_KEY` の取得処理を削除
- [ ] `ApiConfig` のみを使用

#### 2.6 mod.rsの更新
- [ ] `session` モジュールのインポートを削除
- [ ] `SessionManager` の使用箇所を削除

### フェーズ3: 環境変数の整理

#### 3.1 デスクトップアプリの環境変数
- [ ] `.env` から `SESSION_ENCRYPTION_KEY` を削除
- [ ] `.env.example` から `SESSION_ENCRYPTION_KEY` を削除
- [ ] 残す環境変数:
  ```env
  API_SERVER_URL=http://localhost:8787
  ```

#### 3.2 APIサーバーの環境変数
- [ ] 変更なし（既存の設定を維持）
  ```env
  GOOGLE_CLIENT_ID=...
  GOOGLE_CLIENT_SECRET=...
  JWT_SECRET=...
  ```

### フェーズ4: ドキュメントの更新

#### 4.1 GOOGLE_LOGIN.mdの更新
- [ ] SESSION_ENCRYPTION_KEYに関する記述を削除
- [ ] JWT方式の説明を追加
- [ ] リフレッシュトークンの説明を追加
- [ ] 環境変数セクションの更新

#### 4.2 SECURE_STORAGE.mdの更新
- [ ] 暗号化に関する記述を削除
- [ ] JWTトークン保存の説明を追加

#### 4.3 ENVIRONMENT_VARIABLES.mdの更新
- [ ] SESSION_ENCRYPTION_KEYの記述を削除
- [ ] 環境変数リストの更新

### フェーズ5: テスト

#### 5.1 APIサーバー側のテスト
- [ ] JWT検証エンドポイントのテスト
  - 有効なトークンの検証
  - 無効なトークンの検証
  - 期限切れトークンの検証
- [ ] リフレッシュトークンエンドポイントのテスト
  - 有効なリフレッシュトークンでの更新
  - 無効なリフレッシュトークンでの更新

#### 5.2 デスクトップアプリ側のテスト
- [ ] ログインフローのテスト
  - Google認証
  - トークン保存
  - ユーザー情報取得
- [ ] セッション検証のテスト
  - 有効なトークンでの検証
  - 無効なトークンでの検証
- [ ] トークンリフレッシュのテスト
  - 自動リフレッシュ
  - 手動リフレッシュ
- [ ] ログアウトのテスト
  - トークン削除
  - UI更新

#### 5.3 統合テスト
- [ ] エンドツーエンドの認証フロー
- [ ] トークン有効期限切れ時の自動リフレッシュ
- [ ] オフライン時の動作確認

### フェーズ6: マイグレーション

#### 6.1 既存ユーザーのマイグレーション
- [ ] 既存のセッションを無効化
- [ ] ユーザーに再ログインを促す
- [ ] マイグレーション通知の表示

#### 6.2 データベースのクリーンアップ
- [ ] `sessions` テーブルの削除（オプション）
- [ ] 不要なセッションデータの削除

## 実装の優先順位

### 高優先度（必須）
1. APIサーバー側のJWT検証エンドポイント（1.1）
2. デスクトップアプリ側のsession.rs削除（2.1）
3. service.rsの更新（2.3）
4. 環境変数の整理（3.1, 3.2）

### 中優先度（推奨）
1. リフレッシュトークン機能（1.2, 2.3）
2. secure_storage.rsの簡素化（2.2）
3. ドキュメントの更新（4.1, 4.2, 4.3）

### 低優先度（オプション）
1. データベースのクリーンアップ（6.2）
2. 詳細なテスト（5.3）

## セキュリティ上の考慮事項

1. **JWTトークンの保存**
   - Tauri Storeプラグインを使用（OS標準のセキュアストレージ）
   - 平文で保存（JWTは署名済みのため追加の暗号化は不要）

2. **トークンの有効期限**
   - アクセストークン: 1時間（短期）
   - リフレッシュトークン: 30日（長期）

3. **トークンの送信**
   - HTTPS必須（本番環境）
   - Bearerトークン形式

4. **リフレッシュトークンの管理**
   - セキュアストレージに保存
   - 使用後は新しいリフレッシュトークンを発行（オプション）

## 期待される効果

1. **セキュリティの向上**
   - 暗号化キーの管理が不要
   - JWT署名による改ざん防止
   - APIサーバー側での一元管理

2. **実装の簡素化**
   - デスクトップアプリ側のコード削減
   - セッション管理の複雑さの軽減

3. **保守性の向上**
   - 認証ロジックの一元化
   - トークン管理の標準化

4. **スケーラビリティ**
   - 複数デバイス対応が容易
   - トークンベースの認証は水平スケーリングに適している
